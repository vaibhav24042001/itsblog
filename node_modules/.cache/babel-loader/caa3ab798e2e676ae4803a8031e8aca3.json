{"ast":null,"code":"import e, { isValidElement as t, useRef as n, useLayoutEffect as o, useEffect as s, useReducer as a, useState as r, cloneElement as i, forwardRef as c } from \"react\";\nimport l from \"clsx\";\n\nfunction u(e) {\n  return \"number\" == typeof e && !isNaN(e);\n}\n\nfunction d(e) {\n  return \"boolean\" == typeof e;\n}\n\nfunction p(e) {\n  return \"string\" == typeof e;\n}\n\nfunction m(e) {\n  return \"function\" == typeof e;\n}\n\nfunction f(e) {\n  return p(e) || m(e) ? e : null;\n}\n\nfunction g(e) {\n  return 0 === e || e;\n}\n\nfunction y(e) {\n  return t(e) || p(e) || m(e) || u(e);\n}\n\nconst h = {\n  TOP_LEFT: \"top-left\",\n  TOP_RIGHT: \"top-right\",\n  TOP_CENTER: \"top-center\",\n  BOTTOM_LEFT: \"bottom-left\",\n  BOTTOM_RIGHT: \"bottom-right\",\n  BOTTOM_CENTER: \"bottom-center\"\n},\n      T = {\n  INFO: \"info\",\n  SUCCESS: \"success\",\n  WARNING: \"warning\",\n  ERROR: \"error\",\n  DEFAULT: \"default\"\n};\n\nfunction v(e, t, n) {\n  void 0 === n && (n = 300);\n  const {\n    scrollHeight: o,\n    style: s\n  } = e;\n  requestAnimationFrame(() => {\n    s.minHeight = \"initial\", s.height = o + \"px\", s.transition = \"all \" + n + \"ms\", requestAnimationFrame(() => {\n      s.height = \"0\", s.padding = \"0\", s.margin = \"0\", setTimeout(t, n);\n    });\n  });\n}\n\nfunction E(t) {\n  let {\n    enter: a,\n    exit: r,\n    appendPosition: i = !1,\n    collapse: c = !0,\n    collapseDuration: l = 300\n  } = t;\n  return function (t) {\n    let {\n      children: u,\n      position: d,\n      preventExitTransition: p,\n      done: m,\n      nodeRef: f,\n      isIn: g\n    } = t;\n    const y = i ? a + \"--\" + d : a,\n          h = i ? r + \"--\" + d : r,\n          T = n(),\n          E = n(0);\n\n    function b(e) {\n      if (e.target !== f.current) return;\n      const t = f.current;\n      t.dispatchEvent(new Event(\"d\")), t.removeEventListener(\"animationend\", b), t.removeEventListener(\"animationcancel\", b), 0 === E.current && \"animationcancel\" !== e.type && (t.className = T.current);\n    }\n\n    function C() {\n      const e = f.current;\n      e.removeEventListener(\"animationend\", C), c ? v(e, m, l) : m();\n    }\n\n    return o(() => {\n      !function () {\n        const e = f.current;\n        T.current = e.className, e.className += \" \" + y, e.addEventListener(\"animationend\", b), e.addEventListener(\"animationcancel\", b);\n      }();\n    }, []), s(() => {\n      g || (p ? C() : function () {\n        E.current = 1;\n        const e = f.current;\n        e.className += \" \" + h, e.addEventListener(\"animationend\", C);\n      }());\n    }, [g]), e.createElement(e.Fragment, null, u);\n  };\n}\n\nfunction b(e, t) {\n  return {\n    content: e.content,\n    containerId: e.props.containerId,\n    id: e.props.toastId,\n    theme: e.props.theme,\n    type: e.props.type,\n    data: e.props.data || {},\n    isLoading: e.props.isLoading,\n    icon: e.props.icon,\n    status: t\n  };\n}\n\nconst C = {\n  list: new Map(),\n  emitQueue: new Map(),\n\n  on(e, t) {\n    return this.list.has(e) || this.list.set(e, []), this.list.get(e).push(t), this;\n  },\n\n  off(e, t) {\n    if (t) {\n      const n = this.list.get(e).filter(e => e !== t);\n      return this.list.set(e, n), this;\n    }\n\n    return this.list.delete(e), this;\n  },\n\n  cancelEmit(e) {\n    const t = this.emitQueue.get(e);\n    return t && (t.forEach(clearTimeout), this.emitQueue.delete(e)), this;\n  },\n\n  emit(e) {\n    this.list.has(e) && this.list.get(e).forEach(t => {\n      const n = setTimeout(() => {\n        t(...[].slice.call(arguments, 1));\n      }, 0);\n      this.emitQueue.has(e) || this.emitQueue.set(e, []), this.emitQueue.get(e).push(n);\n    });\n  }\n\n};\n\nfunction _(e) {\n  const [, o] = a(e => e + 1, 0),\n        [c, l] = r([]),\n        h = n(null),\n        T = n(new Map()).current,\n        v = e => -1 !== c.indexOf(e),\n        E = n({\n    toastKey: 1,\n    displayedToast: 0,\n    count: 0,\n    queue: [],\n    props: e,\n    containerId: null,\n    isToastActive: v,\n    getToast: e => T.get(e)\n  }).current;\n\n  function _(e) {\n    let {\n      containerId: t\n    } = e;\n    const {\n      limit: n\n    } = E.props;\n    !n || t && E.containerId !== t || (E.count -= E.queue.length, E.queue = []);\n  }\n\n  function I(e) {\n    l(t => g(e) ? t.filter(t => t !== e) : []);\n  }\n\n  function O() {\n    const {\n      toastContent: e,\n      toastProps: t,\n      staleId: n\n    } = E.queue.shift();\n    N(e, t, n);\n  }\n\n  function L(e, n) {\n    let {\n      delay: s,\n      staleId: a,\n      ...r\n    } = n;\n    if (!y(e) || function (e) {\n      return !h.current || E.props.enableMultiContainer && e.containerId !== E.props.containerId || T.has(e.toastId) && null == e.updateId;\n    }(r)) return;\n\n    const {\n      toastId: c,\n      updateId: l,\n      data: v\n    } = r,\n          {\n      props: _\n    } = E,\n          L = () => I(c),\n          P = null == l;\n\n    P && E.count++;\n    const x = {\n      toastId: c,\n      updateId: l,\n      containerId: r.containerId,\n      isLoading: r.isLoading,\n      theme: r.theme || _.theme,\n      icon: null != r.icon ? r.icon : _.icon,\n      isIn: !1,\n      key: r.key || E.toastKey++,\n      type: r.type,\n      closeToast: L,\n      closeButton: r.closeButton,\n      rtl: _.rtl,\n      position: r.position || _.position,\n      transition: r.transition || _.transition,\n      className: f(r.className || _.toastClassName),\n      bodyClassName: f(r.bodyClassName || _.bodyClassName),\n      style: r.style || _.toastStyle,\n      bodyStyle: r.bodyStyle || _.bodyStyle,\n      onClick: r.onClick || _.onClick,\n      pauseOnHover: d(r.pauseOnHover) ? r.pauseOnHover : _.pauseOnHover,\n      pauseOnFocusLoss: d(r.pauseOnFocusLoss) ? r.pauseOnFocusLoss : _.pauseOnFocusLoss,\n      draggable: d(r.draggable) ? r.draggable : _.draggable,\n      draggablePercent: r.draggablePercent || _.draggablePercent,\n      draggableDirection: r.draggableDirection || _.draggableDirection,\n      closeOnClick: d(r.closeOnClick) ? r.closeOnClick : _.closeOnClick,\n      progressClassName: f(r.progressClassName || _.progressClassName),\n      progressStyle: r.progressStyle || _.progressStyle,\n      autoClose: !r.isLoading && (B = r.autoClose, R = _.autoClose, !1 === B || u(B) && B > 0 ? B : R),\n      hideProgressBar: d(r.hideProgressBar) ? r.hideProgressBar : _.hideProgressBar,\n      progress: r.progress,\n      role: r.role || _.role,\n\n      deleteToast() {\n        const e = b(T.get(c), \"removed\");\n        T.delete(c), C.emit(4, e);\n        const t = E.queue.length;\n\n        if (E.count = g(c) ? E.count - 1 : E.count - E.displayedToast, E.count < 0 && (E.count = 0), t > 0) {\n          const e = g(c) ? 1 : E.props.limit;\n          if (1 === t || 1 === e) E.displayedToast++, O();else {\n            const n = e > t ? t : e;\n            E.displayedToast = n;\n\n            for (let e = 0; e < n; e++) O();\n          }\n        } else o();\n      }\n\n    };\n    var B, R;\n    m(r.onOpen) && (x.onOpen = r.onOpen), m(r.onClose) && (x.onClose = r.onClose), x.closeButton = _.closeButton, !1 === r.closeButton || y(r.closeButton) ? x.closeButton = r.closeButton : !0 === r.closeButton && (x.closeButton = !y(_.closeButton) || _.closeButton);\n    let k = e;\n    t(e) && !p(e.type) ? k = i(e, {\n      closeToast: L,\n      toastProps: x,\n      data: v\n    }) : m(e) && (k = e({\n      closeToast: L,\n      toastProps: x,\n      data: v\n    })), _.limit && _.limit > 0 && E.count > _.limit && P ? E.queue.push({\n      toastContent: k,\n      toastProps: x,\n      staleId: a\n    }) : u(s) ? setTimeout(() => {\n      N(k, x, a);\n    }, s) : N(k, x, a);\n  }\n\n  function N(e, t, n) {\n    const {\n      toastId: o\n    } = t;\n    n && T.delete(n);\n    const s = {\n      content: e,\n      props: t\n    };\n    T.set(o, s), l(e => [...e, o].filter(e => e !== n)), C.emit(4, b(s, null == s.props.updateId ? \"added\" : \"updated\"));\n  }\n\n  return s(() => (E.containerId = e.containerId, C.cancelEmit(3).on(0, L).on(1, e => h.current && I(e)).on(5, _).emit(2, E), () => C.emit(3, E)), []), s(() => {\n    E.props = e, E.isToastActive = v, E.displayedToast = c.length;\n  }), {\n    getToastToRender: function (t) {\n      const n = new Map(),\n            o = Array.from(T.values());\n      return e.newestOnTop && o.reverse(), o.forEach(e => {\n        const {\n          position: t\n        } = e.props;\n        n.has(t) || n.set(t, []), n.get(t).push(e);\n      }), Array.from(n, e => t(e[0], e[1]));\n    },\n    containerRef: h,\n    isToastActive: v\n  };\n}\n\nfunction I(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;\n}\n\nfunction O(e) {\n  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;\n}\n\nfunction L(e) {\n  const [o, a] = r(!1),\n        [i, c] = r(!1),\n        l = n(null),\n        u = n({\n    start: 0,\n    x: 0,\n    y: 0,\n    delta: 0,\n    removalDistance: 0,\n    canCloseOnClick: !0,\n    canDrag: !1,\n    boundingRect: null,\n    didMove: !1\n  }).current,\n        d = n(e),\n        {\n    autoClose: p,\n    pauseOnHover: f,\n    closeToast: g,\n    onClick: y,\n    closeOnClick: h\n  } = e;\n\n  function T(t) {\n    if (e.draggable) {\n      u.didMove = !1, document.addEventListener(\"mousemove\", C), document.addEventListener(\"mouseup\", _), document.addEventListener(\"touchmove\", C), document.addEventListener(\"touchend\", _);\n      const n = l.current;\n      u.canCloseOnClick = !0, u.canDrag = !0, u.boundingRect = n.getBoundingClientRect(), n.style.transition = \"\", u.x = I(t.nativeEvent), u.y = O(t.nativeEvent), \"x\" === e.draggableDirection ? (u.start = u.x, u.removalDistance = n.offsetWidth * (e.draggablePercent / 100)) : (u.start = u.y, u.removalDistance = n.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent / 100));\n    }\n  }\n\n  function v() {\n    if (u.boundingRect) {\n      const {\n        top: t,\n        bottom: n,\n        left: o,\n        right: s\n      } = u.boundingRect;\n      e.pauseOnHover && u.x >= o && u.x <= s && u.y >= t && u.y <= n ? b() : E();\n    }\n  }\n\n  function E() {\n    a(!0);\n  }\n\n  function b() {\n    a(!1);\n  }\n\n  function C(t) {\n    const n = l.current;\n    u.canDrag && n && (u.didMove = !0, o && b(), u.x = I(t), u.y = O(t), u.delta = \"x\" === e.draggableDirection ? u.x - u.start : u.y - u.start, u.start !== u.x && (u.canCloseOnClick = !1), n.style.transform = \"translate\" + e.draggableDirection + \"(\" + u.delta + \"px)\", n.style.opacity = \"\" + (1 - Math.abs(u.delta / u.removalDistance)));\n  }\n\n  function _() {\n    document.removeEventListener(\"mousemove\", C), document.removeEventListener(\"mouseup\", _), document.removeEventListener(\"touchmove\", C), document.removeEventListener(\"touchend\", _);\n    const t = l.current;\n\n    if (u.canDrag && u.didMove && t) {\n      if (u.canDrag = !1, Math.abs(u.delta) > u.removalDistance) return c(!0), void e.closeToast();\n      t.style.transition = \"transform 0.2s, opacity 0.2s\", t.style.transform = \"translate\" + e.draggableDirection + \"(0)\", t.style.opacity = \"1\";\n    }\n  }\n\n  s(() => {\n    d.current = e;\n  }), s(() => (l.current && l.current.addEventListener(\"d\", E, {\n    once: !0\n  }), m(e.onOpen) && e.onOpen(t(e.children) && e.children.props), () => {\n    const e = d.current;\n    m(e.onClose) && e.onClose(t(e.children) && e.children.props);\n  }), []), s(() => (e.pauseOnFocusLoss && (document.hasFocus() || b(), window.addEventListener(\"focus\", E), window.addEventListener(\"blur\", b)), () => {\n    e.pauseOnFocusLoss && (window.removeEventListener(\"focus\", E), window.removeEventListener(\"blur\", b));\n  }), [e.pauseOnFocusLoss]);\n  const L = {\n    onMouseDown: T,\n    onTouchStart: T,\n    onMouseUp: v,\n    onTouchEnd: v\n  };\n  return p && f && (L.onMouseEnter = b, L.onMouseLeave = E), h && (L.onClick = e => {\n    y && y(e), u.canCloseOnClick && g();\n  }), {\n    playToast: E,\n    pauseToast: b,\n    isRunning: o,\n    preventExitTransition: i,\n    toastRef: l,\n    eventHandlers: L\n  };\n}\n\nfunction N(t) {\n  let {\n    closeToast: n,\n    theme: o,\n    ariaLabel: s = \"close\"\n  } = t;\n  return e.createElement(\"button\", {\n    className: \"Toastify__close-button Toastify__close-button--\" + o,\n    type: \"button\",\n    onClick: e => {\n      e.stopPropagation(), n(e);\n    },\n    \"aria-label\": s\n  }, e.createElement(\"svg\", {\n    \"aria-hidden\": \"true\",\n    viewBox: \"0 0 14 16\"\n  }, e.createElement(\"path\", {\n    fillRule: \"evenodd\",\n    d: \"M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z\"\n  })));\n}\n\nfunction P(t) {\n  let {\n    delay: n,\n    isRunning: o,\n    closeToast: s,\n    type: a,\n    hide: r,\n    className: i,\n    style: c,\n    controlledProgress: u,\n    progress: d,\n    rtl: p,\n    isIn: f,\n    theme: g\n  } = t;\n  const y = { ...c,\n    animationDuration: n + \"ms\",\n    animationPlayState: o ? \"running\" : \"paused\",\n    opacity: r ? 0 : 1\n  };\n  u && (y.transform = \"scaleX(\" + d + \")\");\n  const h = l(\"Toastify__progress-bar\", u ? \"Toastify__progress-bar--controlled\" : \"Toastify__progress-bar--animated\", \"Toastify__progress-bar-theme--\" + g, \"Toastify__progress-bar--\" + a, {\n    \"Toastify__progress-bar--rtl\": p\n  }),\n        T = m(i) ? i({\n    rtl: p,\n    type: a,\n    defaultClassName: h\n  }) : l(h, i);\n  return e.createElement(\"div\", {\n    role: \"progressbar\",\n    \"aria-hidden\": r ? \"true\" : \"false\",\n    \"aria-label\": \"notification timer\",\n    className: T,\n    style: y,\n    [u && d >= 1 ? \"onTransitionEnd\" : \"onAnimationEnd\"]: u && d < 1 ? null : () => {\n      f && s();\n    }\n  });\n}\n\nP.defaultProps = {\n  type: T.DEFAULT,\n  hide: !1\n};\n\nconst x = t => {\n  let {\n    theme: n,\n    type: o,\n    ...s\n  } = t;\n  return e.createElement(\"svg\", {\n    viewBox: \"0 0 24 24\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"colored\" === n ? \"currentColor\" : \"var(--toastify-icon-color-\" + o + \")\",\n    ...s\n  });\n},\n      B = {\n  info: function (t) {\n    return e.createElement(x, { ...t\n    }, e.createElement(\"path\", {\n      d: \"M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z\"\n    }));\n  },\n  warning: function (t) {\n    return e.createElement(x, { ...t\n    }, e.createElement(\"path\", {\n      d: \"M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z\"\n    }));\n  },\n  success: function (t) {\n    return e.createElement(x, { ...t\n    }, e.createElement(\"path\", {\n      d: \"M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z\"\n    }));\n  },\n  error: function (t) {\n    return e.createElement(x, { ...t\n    }, e.createElement(\"path\", {\n      d: \"M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z\"\n    }));\n  },\n  spinner: function () {\n    return e.createElement(\"div\", {\n      className: \"Toastify__spinner\"\n    });\n  }\n},\n      R = t => {\n  const {\n    isRunning: n,\n    preventExitTransition: o,\n    toastRef: s,\n    eventHandlers: a\n  } = L(t),\n        {\n    closeButton: r,\n    children: i,\n    autoClose: c,\n    onClick: u,\n    type: d,\n    hideProgressBar: f,\n    closeToast: g,\n    transition: y,\n    position: h,\n    className: T,\n    style: v,\n    bodyClassName: E,\n    bodyStyle: b,\n    progressClassName: C,\n    progressStyle: _,\n    updateId: I,\n    role: O,\n    progress: N,\n    rtl: x,\n    toastId: R,\n    deleteToast: k,\n    isIn: M,\n    isLoading: D,\n    icon: w,\n    theme: A\n  } = t,\n        F = l(\"Toastify__toast\", \"Toastify__toast-theme--\" + A, \"Toastify__toast--\" + d, {\n    \"Toastify__toast--rtl\": x\n  }),\n        S = m(T) ? T({\n    rtl: x,\n    position: h,\n    type: d,\n    defaultClassName: F\n  }) : l(F, T),\n        z = !!N,\n        H = B[d],\n        q = {\n    theme: A,\n    type: d\n  };\n  let U = H && H(q);\n  return !1 === w ? U = void 0 : m(w) ? U = w(q) : e.isValidElement(w) ? U = e.cloneElement(w, q) : p(w) ? U = w : D && (U = B.spinner()), e.createElement(y, {\n    isIn: M,\n    done: k,\n    position: h,\n    preventExitTransition: o,\n    nodeRef: s\n  }, e.createElement(\"div\", {\n    id: R,\n    onClick: u,\n    className: S,\n    ...a,\n    style: v,\n    ref: s\n  }, e.createElement(\"div\", { ...(M && {\n      role: O\n    }),\n    className: m(E) ? E({\n      type: d\n    }) : l(\"Toastify__toast-body\", E),\n    style: b\n  }, U && e.createElement(\"div\", {\n    className: l(\"Toastify__toast-icon\", {\n      \"Toastify--animate-icon Toastify__zoom-enter\": !D\n    })\n  }, U), e.createElement(\"div\", null, i)), function (t) {\n    if (!t) return;\n    const n = {\n      closeToast: g,\n      type: d,\n      theme: A\n    };\n    return m(t) ? t(n) : e.isValidElement(t) ? e.cloneElement(t, n) : void 0;\n  }(r), (c || z) && e.createElement(P, { ...(I && !z ? {\n      key: \"pb-\" + I\n    } : {}),\n    rtl: x,\n    theme: A,\n    delay: c,\n    isRunning: n,\n    isIn: M,\n    closeToast: g,\n    hide: f,\n    type: d,\n    style: _,\n    className: C,\n    controlledProgress: z,\n    progress: N\n  })));\n},\n      k = E({\n  enter: \"Toastify--animate Toastify__bounce-enter\",\n  exit: \"Toastify--animate Toastify__bounce-exit\",\n  appendPosition: !0\n}),\n      M = E({\n  enter: \"Toastify--animate Toastify__slide-enter\",\n  exit: \"Toastify--animate Toastify__slide-exit\",\n  appendPosition: !0\n}),\n      D = E({\n  enter: \"Toastify--animate Toastify__zoom-enter\",\n  exit: \"Toastify--animate Toastify__zoom-exit\"\n}),\n      w = E({\n  enter: \"Toastify--animate Toastify__flip-enter\",\n  exit: \"Toastify--animate Toastify__flip-exit\"\n}),\n      A = c((t, n) => {\n  const {\n    getToastToRender: o,\n    containerRef: a,\n    isToastActive: r\n  } = _(t),\n        {\n    className: i,\n    style: c,\n    rtl: u,\n    containerId: d\n  } = t;\n\n  function p(e) {\n    const t = l(\"Toastify__toast-container\", \"Toastify__toast-container--\" + e, {\n      \"Toastify__toast-container--rtl\": u\n    });\n    return m(i) ? i({\n      position: e,\n      rtl: u,\n      defaultClassName: t\n    }) : l(t, f(i));\n  }\n\n  return s(() => {\n    n && (n.current = a.current);\n  }, []), e.createElement(\"div\", {\n    ref: a,\n    className: \"Toastify\",\n    id: d\n  }, o((t, n) => {\n    const o = n.length ? { ...c\n    } : { ...c,\n      pointerEvents: \"none\"\n    };\n    return e.createElement(\"div\", {\n      className: p(t),\n      style: o,\n      key: \"container-\" + t\n    }, n.map((t, o) => {\n      let {\n        content: s,\n        props: a\n      } = t;\n      return e.createElement(R, { ...a,\n        isIn: r(a.toastId),\n        style: {\n          \"--nth\": o + 1,\n          \"--len\": n.length\n        },\n        key: \"toast-\" + a.key,\n        closeButton: !0 === a.closeButton ? N : a.closeButton\n      }, s);\n    }));\n  }));\n});\n\nA.displayName = \"ToastContainer\", A.defaultProps = {\n  position: h.TOP_RIGHT,\n  transition: k,\n  rtl: !1,\n  autoClose: 5e3,\n  hideProgressBar: !1,\n  closeButton: N,\n  pauseOnHover: !0,\n  pauseOnFocusLoss: !0,\n  closeOnClick: !0,\n  newestOnTop: !1,\n  draggable: !0,\n  draggablePercent: 80,\n  draggableDirection: \"x\",\n  role: \"alert\",\n  theme: \"light\"\n};\nlet F,\n    S = new Map(),\n    z = [];\n\nfunction H() {\n  return Math.random().toString(36).substring(2, 9);\n}\n\nfunction q(e) {\n  return e && (p(e.toastId) || u(e.toastId)) ? e.toastId : H();\n}\n\nfunction U(e, t) {\n  return S.size > 0 ? C.emit(0, e, t) : z.push({\n    content: e,\n    options: t\n  }), t.toastId;\n}\n\nfunction Q(e, t) {\n  return { ...t,\n    type: t && t.type || e,\n    toastId: q(t)\n  };\n}\n\nfunction G(e) {\n  return (t, n) => U(t, Q(e, n));\n}\n\nfunction W(e, t) {\n  return U(e, Q(T.DEFAULT, t));\n}\n\nW.loading = (e, t) => U(e, Q(T.DEFAULT, {\n  isLoading: !0,\n  autoClose: !1,\n  closeOnClick: !1,\n  closeButton: !1,\n  draggable: !1,\n  ...t\n})), W.promise = function (e, t, n) {\n  let o,\n      {\n    pending: s,\n    error: a,\n    success: r\n  } = t;\n  s && (o = p(s) ? W.loading(s, n) : W.loading(s.render, { ...n,\n    ...s\n  }));\n\n  const i = {\n    isLoading: null,\n    autoClose: null,\n    closeOnClick: null,\n    closeButton: null,\n    draggable: null,\n    delay: 100\n  },\n        c = (e, t, s) => {\n    if (null == t) return void W.dismiss(o);\n    const a = {\n      type: e,\n      ...i,\n      ...n,\n      data: s\n    },\n          r = p(t) ? {\n      render: t\n    } : t;\n    return o ? W.update(o, { ...a,\n      ...r\n    }) : W(r.render, { ...a,\n      ...r\n    }), s;\n  },\n        l = m(e) ? e() : e;\n\n  return l.then(e => c(\"success\", r, e)).catch(e => c(\"error\", a, e)), l;\n}, W.success = G(T.SUCCESS), W.info = G(T.INFO), W.error = G(T.ERROR), W.warning = G(T.WARNING), W.warn = W.warning, W.dark = (e, t) => U(e, Q(T.DEFAULT, {\n  theme: \"dark\",\n  ...t\n})), W.dismiss = e => C.emit(1, e), W.clearWaitingQueue = function (e) {\n  return void 0 === e && (e = {}), C.emit(5, e);\n}, W.isActive = e => {\n  let t = !1;\n  return S.forEach(n => {\n    n.isToastActive && n.isToastActive(e) && (t = !0);\n  }), t;\n}, W.update = function (e, t) {\n  void 0 === t && (t = {}), setTimeout(() => {\n    const n = function (e, t) {\n      let {\n        containerId: n\n      } = t;\n      const o = S.get(n || F);\n      return o ? o.getToast(e) : null;\n    }(e, t);\n\n    if (n) {\n      const {\n        props: o,\n        content: s\n      } = n,\n            a = { ...o,\n        ...t,\n        toastId: t.toastId || e,\n        updateId: H()\n      };\n      a.toastId !== e && (a.staleId = e);\n      const r = a.render || s;\n      delete a.render, U(r, a);\n    }\n  }, 0);\n}, W.done = e => {\n  W.update(e, {\n    progress: 1\n  });\n}, W.onChange = e => (C.on(4, e), () => {\n  C.off(4, e);\n}), W.POSITION = h, W.TYPE = T, C.on(2, e => {\n  F = e.containerId || e, S.set(F, e), z.forEach(e => {\n    C.emit(0, e.content, e.options);\n  }), z = [];\n}).on(3, e => {\n  S.delete(e.containerId || e), 0 === S.size && C.off(0).off(1).off(5);\n});\nexport { k as Bounce, w as Flip, B as Icons, M as Slide, A as ToastContainer, D as Zoom, v as collapseToast, E as cssTransition, W as toast, L as useToast, _ as useToastContainer }; //# sourceMappingURL=react-toastify.esm.js.map","map":null,"metadata":{},"sourceType":"module"}